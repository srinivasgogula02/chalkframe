<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Valley of Focus - Alive</title>
    <style>
        :root { 
            --primary: #2E7D32; 
            --accent: #81C784;
            --danger: #c62828; 
            --surface: rgba(255, 255, 255, 0.95);
        }
        
        body { 
            margin: 0; overflow: hidden; background: #87CEEB;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            -webkit-tap-highlight-color: transparent;
        }
        
        canvas { display: block; outline: none; }

        /* --- QUICK ACTION FAB --- */
        #fab-add {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            width: 60px; height: 60px;
            background: var(--primary); color: white;
            border-radius: 50%; border: none;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            font-size: 2rem; display: flex; align-items: center; justify-content: center;
            cursor: pointer; z-index: 95; transition: transform 0.2s;
        }
        #fab-add:active { transform: translateX(-50%) scale(0.9); }
        #fab-add span { margin-top: -4px; }

        /* --- SIDEBAR --- */
        #sidebar {
            position: absolute; top: 0; left: 0; bottom: 0;
            width: 100%; max-width: 400px;
            background: var(--surface); backdrop-filter: blur(10px);
            box-shadow: 4px 0 30px rgba(0,0,0,0.2);
            transform: translateX(-105%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 100; display: flex; flex-direction: column;
        }
        #sidebar.open { transform: translateX(0); }
        
        .sb-header { 
            padding: 20px; border-bottom: 1px solid #eee; 
            display: flex; justify-content: space-between; align-items: center;
        }
        h2 { margin: 0; font-size: 1.4rem; color: #222; }
        .close-btn {
            background: none; border: none; font-size: 2rem; color: #666;
            cursor: pointer; padding: 0 10px; line-height: 1;
        }

        .tabs { display: flex; border-bottom: 1px solid #eee; background: rgba(0,0,0,0.02); }
        .tab { 
            flex: 1; padding: 15px 0; border: none; background: none; 
            font-weight: 600; color: #888; cursor: pointer; position: relative;
        }
        .tab.active { color: var(--primary); background: white; }
        .tab.active::after {
            content: ''; position: absolute; bottom: 0; left: 0; right: 0; height: 3px; background: var(--primary);
        }

        #goal-list { flex: 1; overflow-y: auto; padding: 15px; }
        
        .goal-item {
            background: white; border-radius: 12px; padding: 15px; margin-bottom: 10px;
            border: 1px solid #eee; box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .goal-item.active { border-left: 5px solid var(--primary); }
        
        .gi-top { display: flex; justify-content: space-between; margin-bottom: 10px; }
        .gi-name { font-weight: bold; font-size: 1.1rem; }
        .gi-days { font-size: 0.9rem; color: #666; background: #f0f0f0; padding: 2px 8px; border-radius: 10px; }
        
        .gi-actions { display: flex; gap: 10px; }
        .btn-act { flex: 1; padding: 10px; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; }
        .btn-yes { background: #E8F5E9; color: var(--primary); }
        .btn-no { background: #FFEBEE; color: var(--danger); }

        /* --- MODAL --- */
        #add-modal {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5); z-index: 200;
            display: flex; align-items: center; justify-content: center;
            opacity: 0; pointer-events: none; transition: opacity 0.2s;
        }
        #add-modal.show { opacity: 1; pointer-events: all; }
        .modal-content {
            background: white; width: 85%; max-width: 320px;
            padding: 25px; border-radius: 20px;
            transform: scale(0.9); transition: transform 0.2s;
        }
        #add-modal.show .modal-content { transform: scale(1); }
        input { width: 100%; padding: 12px; margin-bottom: 15px; border: 1px solid #ddd; border-radius: 8px; box-sizing: border-box; }
        .btn-plant { width: 100%; padding: 14px; background: var(--primary); color: white; border: none; border-radius: 8px; font-weight: bold; }
        .btn-cancel { width: 100%; padding: 10px; background: none; color: #666; border: none; margin-top: 10px; }

        #desktop-menu {
            position: absolute; top: 20px; left: 20px;
            background: white; padding: 10px; border-radius: 50%;
            width: 44px; height: 44px; display: flex; align-items: center; justify-content: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1); cursor: pointer; z-index: 90; font-size: 1.2rem;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>
<body>

    <div id="desktop-menu">☰</div>
    <button id="fab-add"><span>+</span></button>

    <div id="sidebar">
        <div class="sb-header">
            <h2>Valley of Focus</h2>
            <button class="close-btn" id="close-sidebar">×</button>
        </div>
        <div class="tabs">
            <button class="tab active" onclick="App.switchTab('active')">Active</button>
            <button class="tab" onclick="App.switchTab('dead')">Graveyard</button>
        </div>
        <div id="goal-list"></div>
    </div>

    <div id="add-modal">
        <div class="modal-content">
            <h3 style="margin-top:0">Plant New Goal</h3>
            <input type="text" id="m-name" placeholder="Goal Name">
            <input type="number" id="m-days" placeholder="Days" value="30">
            <button class="btn-plant" id="btn-modal-add">Plant Tree</button>
            <button class="btn-cancel" id="btn-modal-close">Cancel</button>
        </div>
    </div>

    <script>
        // --- 1. AUDIO ENGINE (With Magic Sound) ---
        const AudioEngine = {
            ctx: null, master: null,
            init: function() {
                const AC = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AC();
                this.master = this.ctx.createGain();
                this.master.connect(this.ctx.destination);
                
                // Wind
                const buf = this.ctx.createBuffer(1, this.ctx.sampleRate*2, this.ctx.sampleRate);
                const data = buf.getChannelData(0);
                for(let i=0; i<data.length; i++) data[i] = (Math.random()*2-1)*0.5;
                const src = this.ctx.createBufferSource(); src.buffer = buf; src.loop = true;
                const f = this.ctx.createBiquadFilter(); f.type = 'lowpass'; f.frequency.value = 300;
                const g = this.ctx.createGain(); g.gain.value = 0.05;
                src.connect(f); f.connect(g); g.connect(this.master);
                src.start();
            },
            playMagic: function() {
                if(!this.ctx) this.init();
                if(this.ctx.state === 'suspended') this.ctx.resume();
                
                const t = this.ctx.currentTime;
                // High glimmer sound
                const osc = this.ctx.createOscillator();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(500, t);
                osc.frequency.exponentialRampToValueAtTime(1200, t+0.5);
                
                const g = this.ctx.createGain();
                g.gain.setValueAtTime(0, t);
                g.gain.linearRampToValueAtTime(0.3, t+0.1);
                g.gain.exponentialRampToValueAtTime(0.01, t+1.5);
                
                osc.connect(g); g.connect(this.master);
                osc.start(t); osc.stop(t+1.5);

                // Lower harmonic
                const osc2 = this.ctx.createOscillator();
                osc2.type = 'triangle';
                osc2.frequency.setValueAtTime(250, t);
                osc2.frequency.linearRampToValueAtTime(300, t+1);
                const g2 = this.ctx.createGain();
                g2.gain.setValueAtTime(0, t);
                g2.gain.linearRampToValueAtTime(0.1, t+0.1);
                g2.gain.linearRampToValueAtTime(0, t+1);
                osc2.connect(g2); g2.connect(this.master);
                osc2.start(t); osc2.stop(t+1);
            }
        };

        // --- 2. 3D SCENE ---
        const Scene = {
            scene: null, camera: null, renderer: null, controls: null,
            raycaster: new THREE.Raycaster(), mouse: new THREE.Vector2(),
            activeLabel: null, // Track currently open label

            init: function() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB);
                this.scene.fog = new THREE.Fog(0x87CEEB, 20, 80);

                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
                this.camera.position.set(0, 15, 30);

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.body.appendChild(this.renderer.domElement);

                const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
                this.scene.add(hemi);
                const sun = new THREE.DirectionalLight(0xfff5e1, 1.2);
                sun.position.set(30, 60, 30);
                sun.castShadow = true;
                sun.shadow.mapSize.width = 1024; sun.shadow.mapSize.height = 1024;
                this.scene.add(sun);

                this.createGround();
                
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.maxPolarAngle = Math.PI/2 - 0.05;

                // CLICK HANDLING
                let downTime = 0;
                window.addEventListener('pointerdown', () => downTime = Date.now());
                window.addEventListener('pointerup', (e) => {
                    if(Date.now() - downTime < 200) this.onTap(e);
                });
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth/window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });

                this.animate();
            },

            createGround: function() {
                const simplex = new SimplexNoise();
                const geo = new THREE.PlaneGeometry(200, 200, 100, 100);
                const pos = geo.attributes.position;
                const colors = [];
                const c1 = new THREE.Color(0x689F38); 
                const c2 = new THREE.Color(0xDCEDC8); 
                for(let i=0; i<pos.count; i++){
                    const x = pos.getX(i); const y = pos.getY(i);
                    let z = simplex.noise2D(x*0.02, y*0.02) * 2;
                    z += simplex.noise2D(x*0.05, y*0.05) * 0.5;
                    pos.setZ(i, z);
                    const mix = (z+2.5)/5;
                    const c = c1.clone().lerp(c2, mix);
                    colors.push(c.r, c.g, c.b);
                }
                geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                geo.computeVertexNormals();
                const mat = new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 1 });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.rotation.x = -Math.PI/2;
                mesh.receiveShadow = true;
                this.scene.add(mesh);
                this.getH = (x,z) => simplex.noise2D(x*0.02, -z*0.02)*2 + simplex.noise2D(x*0.05, -z*0.05)*0.5;
            },

            createLabelTexture: function(text, subtext) {
                const cvs = document.createElement('canvas');
                cvs.width = 512; cvs.height = 256;
                const ctx = cvs.getContext('2d');
                
                // Background bubble
                ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
                ctx.beginPath();
                ctx.roundRect(10, 10, 492, 236, 40);
                ctx.fill();
                ctx.strokeStyle = "#2E7D32";
                ctx.lineWidth = 10;
                ctx.stroke();

                // Text
                ctx.fillStyle = "#333";
                ctx.font = "bold 70px Arial";
                ctx.textAlign = "center";
                ctx.fillText(text, 256, 110);
                
                ctx.fillStyle = "#2E7D32";
                ctx.font = "bold 60px Arial";
                ctx.fillText(subtext, 256, 200);

                const tex = new THREE.CanvasTexture(cvs);
                return tex;
            },

            plantTree: function(goal) {
                const x = (Math.random()-0.5)*50;
                const z = (Math.random()-0.5)*50;
                const y = this.getH(x,z);
                
                const group = new THREE.Group();
                group.position.set(x,y,z);
                group.userData = { id: goal.id };

                // TRUNK
                const tGeo = new THREE.CylinderGeometry(0.1, 0.3, 1.5, 7);
                const woodMat = new THREE.MeshStandardMaterial({ color: 0x5D4037, flatShading: true });
                const trunk = new THREE.Mesh(tGeo, woodMat);
                trunk.position.y = 0.75;
                trunk.castShadow = true; 
                trunk.name = "TRUNK";
                group.add(trunk);

                // CANOPY
                const canopy = new THREE.Group();
                canopy.position.y = 1.2; 
                canopy.name = "CANOPY";
                
                const leafMat = new THREE.MeshStandardMaterial({ color: 0x43A047, flatShading: true });
                // Branches
                for(let i=0; i<4; i++) {
                    const bCont = new THREE.Group();
                    bCont.rotation.y = (i/4)*Math.PI*2;
                    const b = new THREE.Mesh(new THREE.CylinderGeometry(0.05,0.1,0.8,4), woodMat);
                    b.position.set(0, 0.4, 0.2); b.rotation.x = Math.PI/4;
                    bCont.add(b);
                    const l = new THREE.Mesh(new THREE.DodecahedronGeometry(0.4), leafMat);
                    l.position.set(0, 0.8, 0.5); l.castShadow=true; l.name="LEAF";
                    bCont.add(l);
                    canopy.add(bCont);
                }
                const topL = new THREE.Mesh(new THREE.DodecahedronGeometry(0.5), leafMat);
                topL.position.y = 0.5; topL.castShadow=true; topL.name="LEAF";
                canopy.add(topL);
                group.add(canopy);

                // LABEL (Sprite)
                const map = this.createLabelTexture(goal.name, `${goal.streak}/${goal.totalDays} Days`);
                const mat = new THREE.SpriteMaterial({ map: map });
                const sprite = new THREE.Sprite(mat);
                sprite.position.set(0, 4, 0); // Float above tree
                sprite.scale.set(4, 2, 1);
                sprite.visible = false; // Hidden by default
                sprite.name = "LABEL";
                group.add(sprite);

                this.scene.add(group);
                goal.mesh = group;
                this.updateTree(goal);
                return group.position;
            },

            updateTree: function(goal) {
                if(!goal.mesh) return;
                const canopy = goal.mesh.getObjectByName("CANOPY");
                const trunk = goal.mesh.getObjectByName("TRUNK");
                const label = goal.mesh.getObjectByName("LABEL");

                // Update Label Text
                label.material.map = this.createLabelTexture(goal.name, `${goal.streak}/${goal.totalDays} Days`);

                if(goal.status === 'dead') {
                    trunk.material = new THREE.MeshStandardMaterial({ color: 0x4E342E });
                    canopy.traverse(o => { if(o.name==="LEAF") o.visible=false; });
                } else {
                    // Current Scale
                    const p = Math.min(1, goal.streak / goal.totalDays);
                    const scale = 0.5 + (p * 1.5); 
                    
                    trunk.scale.set(1+p, scale, 1+p);
                    canopy.position.y = (scale * 0.7) + 0.5;
                    canopy.scale.setScalar(scale);
                    
                    // Adjust label height based on growth
                    label.position.y = 2 + (scale * 1.5);
                }
            },

            animateGrowth: function(goal) {
                if(!goal.mesh) return;
                
                // Sound
                AudioEngine.playMagic();

                // 1. Zoom Camera
                this.zoomTo(goal.mesh.position);

                // 2. Animate Scale
                const canopy = goal.mesh.getObjectByName("CANOPY");
                const trunk = goal.mesh.getObjectByName("TRUNK");
                const label = goal.mesh.getObjectByName("LABEL");

                const p = Math.min(1, goal.streak / goal.totalDays);
                const targetScale = 0.5 + (p * 1.5);
                const startScale = canopy.scale.x; // Current scale

                const anim = { s: startScale };
                
                new TWEEN.Tween(anim)
                    .to({ s: targetScale }, 2000) // 2 second growth
                    .easing(TWEEN.Easing.Elastic.Out)
                    .onUpdate(() => {
                        trunk.scale.set(1+p, anim.s, 1+p);
                        canopy.position.y = (anim.s * 0.7) + 0.5;
                        canopy.scale.setScalar(anim.s);
                        label.position.y = 2 + (anim.s * 1.5);
                    })
                    .start();
            },

            onTap: function(e) {
                this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const hits = this.raycaster.intersectObjects(this.scene.children, true);
                
                // Hide existing label if any
                if(this.activeLabel) {
                    this.activeLabel.visible = false;
                    this.activeLabel = null;
                }

                for(let hit of hits) {
                    let obj = hit.object;
                    while(obj.parent && obj.parent.type !== 'Scene') {
                        // Found a tree
                        if(obj.userData.id) {
                            // Show Label
                            const label = obj.getObjectByName("LABEL");
                            if(label) {
                                label.visible = true;
                                this.activeLabel = label;
                                
                                // Also slight bounce effect on label
                                label.scale.set(0,0,0);
                                new TWEEN.Tween(label.scale)
                                    .to({x:4, y:2, z:1}, 400)
                                    .easing(TWEEN.Easing.Back.Out)
                                    .start();
                            }
                            return;
                        }
                        obj = obj.parent;
                    }
                }
            },

            zoomTo: function(pos) {
                const endPos = pos.clone().add(new THREE.Vector3(5, 4, 5)); // Close up angle
                const endTarget = pos.clone().add(new THREE.Vector3(0, 1, 0)); // Look at tree center

                new TWEEN.Tween(this.camera.position).to(endPos, 1500).easing(TWEEN.Easing.Cubic.Out).start();
                new TWEEN.Tween(this.controls.target).to(endTarget, 1500).easing(TWEEN.Easing.Cubic.Out).start();
            },

            animate: function(time) {
                requestAnimationFrame((t) => this.animate(t));
                TWEEN.update(time);
                // Make label face camera
                if(this.activeLabel) {
                    // Simple sprite always faces camera natively, no code needed for rotation
                    // But we might want bobbing?
                    this.activeLabel.position.y += Math.sin(time * 0.005) * 0.005; 
                }
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }
        };

        // --- 3. APP LOGIC ---
        const App = {
            goals: [], activeTab: 'active',
            
            init: function() {
                Scene.init();
                this.sidebar = document.getElementById('sidebar');
                this.fab = document.getElementById('fab-add');
                this.modal = document.getElementById('add-modal');
                
                document.getElementById('desktop-menu').onclick = () => this.toggleSidebar(true);
                document.getElementById('close-sidebar').onclick = () => this.toggleSidebar(false);
                
                this.fab.onclick = () => this.modal.classList.add('show');
                document.getElementById('btn-modal-close').onclick = () => this.modal.classList.remove('show');
                document.getElementById('btn-modal-add').onclick = () => this.createGoal();

                this.addGoalToData("Morning Jog", 30);
            },

            toggleSidebar: function(open) {
                if(open) this.sidebar.classList.add('open');
                else this.sidebar.classList.remove('open');
            },
            switchTab: function(tab) {
                this.activeTab = tab;
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                event.target.classList.add('active');
                this.renderList();
            },
            createGoal: function() {
                const name = document.getElementById('m-name').value;
                const days = parseInt(document.getElementById('m-days').value);
                if(!name) return;
                this.addGoalToData(name, days);
                this.modal.classList.remove('show');
                document.getElementById('m-name').value = '';
            },
            addGoalToData: function(name, days) {
                const goal = { id: Date.now(), name: name, totalDays: days, streak: 0, status: 'active', mesh: null };
                this.goals.push(goal);
                const pos = Scene.plantTree(goal);
                Scene.zoomTo(pos);
                this.renderList();
            },
            process: function(id, type) {
                const g = this.goals.find(x => x.id === id);
                if(!g) return;
                
                if(type === 'check') {
                    g.streak++;
                    if(g.streak >= g.totalDays) g.status = 'completed';
                    
                    // TRIGGER GROWTH ANIMATION
                    Scene.updateTree(g); // Update internal state stats
                    Scene.animateGrowth(g); // Play animation and sound
                    
                    // Close sidebar to show the show
                    if(window.innerWidth < 768) this.toggleSidebar(false);
                } else {
                    g.status = 'dead';
                    Scene.updateTree(g);
                }
                this.renderList();
            },
            renderList: function() {
                const list = document.getElementById('goal-list');
                list.innerHTML = '';
                const visible = this.goals.filter(g => g.status === this.activeTab);
                if(visible.length === 0) list.innerHTML = `<div style="text-align:center;color:#999;">No goals here.</div>`;

                visible.forEach(g => {
                    const el = document.createElement('div');
                    el.className = `goal-item ${g.status}`;
                    let btns = '';
                    if(g.status === 'active') {
                        btns = `
                        <div class="gi-actions">
                            <button class="btn-act btn-yes" onclick="App.process(${g.id}, 'check')">✓ Done</button>
                            <button class="btn-act btn-no" onclick="App.process(${g.id}, 'fail')">✗ Missed</button>
                        </div>`;
                    }
                    el.innerHTML = `
                        <div class="gi-top"><span class="gi-name">${g.name}</span><span class="gi-days">${g.streak}/${g.totalDays}</span></div>
                        ${btns}
                    `;
                    list.appendChild(el);
                });
            }
        };

        App.init();

    </script>
</body>
</html>
